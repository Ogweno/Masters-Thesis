#!/bin/sh
#  Parse an exhaustive search description of a RF inversion model, and generate
#  candidate models for input to rfksyn.  Description read from standard input.
#
#  By G. Helffrich/U. Bristol, 31 July 2006.
#
#  Any line beginning with # or * is treated as a comment.
#
#  Three types of input lines:
#
#  halfspace vp <real> vs <real> rho <real>
#  layer <int> vp   <real> <real> <real> n <int> ( 
#              vs   <real> <real> <real> n <int> |
#              pois <real> <real> <real> n <int> )
#              rho  <real> <real> (vp | vs) 
#              thick <real> <real> n <int>
#  prefix <name>
#
#  A successful model must have a halfspace defined, and layers 1-n.  If
#  prefix line is given, all the model files are generated using the prefix
#  given.
#
#  Each layer specifies a range of vp, vs and thickness values to generate.
#  Ranges are specified by a ref value, low and high increment to reference and
#  a number of steps.  Thus vp 6.0 -0.2 +0.2 n 5 would range from 5.8 to 6.2 in
#  steps of 0.1.
#  Vs can be specified either directly, or as a poisson's ratio
#  value.  Use ... vs xx yy zz n ii ... or ... pois xx yy zz n ii ... to specify
#  which method.
#  Density is specified by a Nafe-Drake or Birch relationship:
#    rho xx yy vp indicates rho=xx + yy*vp and rho xx yy vs means rho=xx + yy*vs
#  Wise users should:
#     1) try first without a prefix line to make sure you aren't generating
#        too many models -- this is really easy to do by mistake.
#     2) make the prefix /tmp/xxx... so that the models clog up temporary
#        space rather than permanent space.
#
awk 'func vpois(pvel,sig){
   #Vs as function of Vp and Poisson ratio
   return pvel/sqrt(2*(1-sig)/(1-2*sig))
}
func pr(vp,vs) {
   #Poisson ratio from vp and vs
   r=vp/vs; return (r*r - 2)/(2*(r*r-1))
}
func max(x,y) {
   if (x>=y) return x; return y
}
BEGIN{lmax=0; pfx=""; err=0}
/^[#*]/{next}
/halfspace +vp +[^ ]+ vs [^ ]+ rho [^ ]/{
   hs=1; hsvp=$3; hsvs=$5; hsrho=$7
   next
}
/layer +[0-9]+ +vp +[^ ]+ +[^ ]+ +[^ ]+ +n +[0-9]+ +((vs)|(pois)) +[^ ]+ +[^ ]+ +[^ ]+ +n +[0-9]+ +rho +[^ ]+ +[^ ]+ +((vp)|(vs)) +th(ick)? +[^ ]+ +[^ ]+ +n +[^ ]+/{
   l=$2
   if (l > lmax) lmax=l
   vpref[l] =$4;   vplo[l]=$5;    vphi[l]=$6;    vpn[l]=$8-1;    vpi[l]=0
   vsref[l]=$(10); vslo[l]=$(11); vshi[l]=$(12); vsn[l]=$(14)-1; vsi[l]=0
   layrel[l]=$9
   rhoc[l]=$(16); rhof[l]=$(17); rhorel[l]=$(18)
   thlo[l]=$(20); thhi[l]=$(21); thn[l]=$(23)-1; thi[l]=0
   lay[l]=$8*$(14)*$(23)
   if (lay[l] > 999999) {
      printf "**Layer %d:  too many combinations (%d; max 999999)\n",l,lay[l]
      err=1
   }
   next
}
/prefix/{pfx=$2; next}
{printf "**Invalid syntax line %d: %s\n",NR,$0; err=1}
END{
   ntot=1; for(i=1;i<=lmax;i++) {
      if (lay[i]<=0) {
	 printf "**Missing description for layer %d\n",i
	 err=1
      } else
	 ntot*=lay[i]
   }
   if (hs<=0) {
      print "**No halfspace provided"; err=1
   }
   printf "%d models to be generated",ntot
   if (pfx!="") printf " with prefix %s",pfx
   printf ".\n"
   if (err>0 || pfx=="") exit

   #  Generate models
   do {
      mid=""; dir=""
      for(i=1; i<=lmax; i++) {
	 vp[i]=vpref[i] + (vphi[i]-vplo[i])/max(1,vpn[i])*vpi[i] + vplo[i]
	 vs[i]=vsref[i] + (vshi[i]-vslo[i])/max(1,vsn[i])*vsi[i] + vslo[i]
	 if (layrel[i] == "pois") vs[i]=vpois(vp[i],vs[i])
	 if (rhorel[i] == "vs") vel=vs[i]; else vel=vp[i]
	 rho[i]=rhoc[i]+vel*rhof[i]
	 th[i]=thlo[i] + (thhi[i]-thlo[i])/max(1,thn[i])*thi[i]
	 mid=sprintf("%s%02d%02d%02d",mid,vpi[i],vsi[i],thi[i])
	 dir=sprintf("%s%02d/%02d/%02d/",dir,vpi[i],vsi[i],thi[i])
      }
      dname=pfx substr(dir,1,length(dir)-3)
      system("mkdir -p " dname)
      if (1) { 
	 fname=dname mid
	 printf "File %s opened\n",fname > "/dev/tty"
	 printf "%3d %s\n",1+lmax,mid > fname
	 for(i=1; i<=lmax; i++) {
	    printf "%3d %8.4f %7.4f %7.4f %7.4f  0.0000  0.0000  0.0000  0.0000 %7.4f\n",i,vp[i],vs[i],rho[i],th[i],pr(vp[i],vs[i]) > fname
	 }
	 printf "%3d %8.4f %7.4f %7.4f %7.4f  0.0000  0.0000  0.0000  0.0000 %7.4f\n",i,hsvp,hsvs,hsrho,0.0,pr(hsvp,hsvs) > fname
	 close(fname)
      }
      printf "File %s written\n",fname > "/dev/tty"
      enumerating=1
      for(i=1; i<=lmax; i++) {
	 if (++vpi[i] <= vpn[i]) break; vpi[i]=0
	 if (++vsi[i] <= vsn[i]) break; vsi[i]=0
	 if (++thi[i] <= thn[i]) break; thi[i]=0
	 enumerating = (i != lmax) || (vpi[i]+vsi[i]+thi[i])
      }
   } while(enumerating);
}'
#
# 2 simple                          
# 1   6.0000  3.4641  2.6900 35.0000  0.0000  0.0000  0.0000  0.0000  0.2500
# 2   8.0000  4.6188  3.3300  0.0000  0.0000  0.0000  0.0000  0.0000  0.2500
